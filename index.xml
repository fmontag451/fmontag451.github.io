<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>/dev/null</title>
    <link>https://nazavode.github.io/</link>
    <description>Recent content on /dev/null</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 21 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://nazavode.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Look ma, no CUDA! Programming GPUs with modern C&#43;&#43; and SYCL</title>
      <link>https://nazavode.github.io/blog/sycl/</link>
      <pubDate>Sun, 21 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://nazavode.github.io/blog/sycl/</guid>
      <description>&lt;p&gt;Back in 2009 when I began doing real work with GPGPUs and &lt;a href=&#34;https://en.wikipedia.org/wiki/CUDA&#34;&gt;CUDA&lt;/a&gt;
in the context of large scale HPC simulations, the developer experience was &lt;em&gt;dreadful&lt;/em&gt;.
Sure, for the right algorithm and after lots of blood and tears, performances usually
turned out excellent. But before production, comes the poor developer.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Understanding performance with Google Benchmark @ Italian C&#43;&#43; Meetup</title>
      <link>https://nazavode.github.io/blog/google-benchmark/</link>
      <pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://nazavode.github.io/blog/google-benchmark/</guid>
      <description>&lt;p&gt;During the last meetup of the &lt;a href=&#34;https://twitter.com/italiancpp&#34;&gt;Italian C++ Community&lt;/a&gt; in
Modena, Italy I had the chance to give a talk about profiling C++ code. The whole game
boils down to &lt;em&gt;understanding&lt;/em&gt; what&amp;rsquo;s going on when you have to cope with &lt;em&gt;very smart&lt;/em&gt;
optimizing compilers, NUMA architectures and speculative, superscalar CPUs: in this quest
for knowledge we are lucky enough to have some extremely useful tools like the &lt;em&gt;holy&lt;/em&gt;
&lt;code&gt;perf&lt;/code&gt; and micro benchmarks, using the excellent
&lt;a href=&#34;https://github.com/google/benchmark&#34;&gt;Google Benchmark&lt;/a&gt; for instance.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Salvaging 10 years of Trac while moving to GitLab: tooling for a better life</title>
      <link>https://nazavode.github.io/blog/tracboat/</link>
      <pubDate>Tue, 11 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://nazavode.github.io/blog/tracboat/</guid>
      <description>&lt;p&gt;Some time ago in my team at work we began considering a complete makeover of our devops
infrastructure. The platform in use was based on &lt;strong&gt;&lt;a href=&#34;https://trac.edgewall.org/&#34;&gt;Trac&lt;/a&gt;&lt;/strong&gt;, a tool that ten
years ago proved itself packed with features, looked great and came in the form of an
open, clear and easily extensible Python code base. Almost &lt;strong&gt;a mandatory choice back
then&lt;/strong&gt;. It served us &lt;em&gt;very&lt;/em&gt; well (thanks Trac folks!), even when it had to run on
underpowered hardware, without maintenance and under heavy loads. Despite its stability
and practicality, the need for a proper, &lt;em&gt;modern&lt;/em&gt; devops platform seamlessly supporting
continuous integration and deployment pipelines, as well as code review, suddenly came
out. &lt;strong&gt;The choice went for &lt;a href=&#34;https://gitlab.com/&#34;&gt;GitLab&lt;/a&gt;&lt;/strong&gt;, a solution that would have given us
the same degree of freedom (free community edition, open source, easily manageable on
premise) along all the shiny new features we were looking for.&lt;/p&gt;

&lt;p&gt;At that point, &lt;strong&gt;the issue of how to migrate all of the content came out&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Aliasing Explained (Part 1)</title>
      <link>https://nazavode.github.io/blog/aliasing/</link>
      <pubDate>Sun, 26 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://nazavode.github.io/blog/aliasing/</guid>
      <description>&lt;p&gt;Since my job involves a lot of HPC stuff and performance-obsessed code, one of
the first topics I had to dive into was &lt;strong&gt;aliasing in the C standard&lt;/strong&gt;. I
found out that it is a subtle topic, quite obscure and very often
overlooked even by the most experienced programmers. This post is an attempt
to clarify the concept of &lt;em&gt;aliasing&lt;/em&gt;, why should we care, how it impacts
the code generated by the compiler and how can we master it with no hassle.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://nazavode.github.io/about/</link>
      <pubDate>Thu, 17 Dec 2015 23:53:53 +0100</pubDate>
      
      <guid>https://nazavode.github.io/about/</guid>
      <description>Hi! I am Federico Ficarelli, I work as an HPC software engineer at the Italian National Supercomputing Center where Iâ€™m involved in several High Performance Computing projects focusing on industrial R&amp;amp;D and scientific research. I&amp;rsquo;m interested in programming languages (mainly C++, C, Fortran, Python, Go and some more), compilers, weird architectures, concurrency paradigms and performance optimization. When I&amp;rsquo;m not busy on code, I develop and print my own pictures in the darkroom.</description>
    </item>
    
    <item>
      <title>Move on</title>
      <link>https://nazavode.github.io/blog/first/</link>
      <pubDate>Thu, 17 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://nazavode.github.io/blog/first/</guid>
      <description>&lt;p&gt;Just moved my &lt;a href=&#34;https://devnone.wordpress.com&#34;&gt;old blog&lt;/a&gt; to the combo that mixes
&lt;a href=&#34;https://pages.github.com/&#34;&gt;GitHub Pages&lt;/a&gt; and the amazing
&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; static site generator.&lt;/p&gt;

&lt;p&gt;What about the transition?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Idiomatic C&#43;&#43;</title>
      <link>https://nazavode.github.io/blog/idiomatic-cpp/</link>
      <pubDate>Thu, 20 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>https://nazavode.github.io/blog/idiomatic-cpp/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve just &lt;a href=&#34;http://www.slideshare.net/fficarelli/idiomatic-c&#34;&gt;uploaded&lt;/a&gt; a minimal collection of most wanted and widely accepted idioms and coding conventions
for C++ development presented along with examples and comments. The lecture targets performance oriented codes so
emphasis is on performance-friendly techniques.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Documentation with Doxygen and CMake: a (slightly) improved approach</title>
      <link>https://nazavode.github.io/blog/cmake-doxygen-improved/</link>
      <pubDate>Sat, 19 Jan 2013 00:00:00 +0000</pubDate>
      
      <guid>https://nazavode.github.io/blog/cmake-doxygen-improved/</guid>
      <description>&lt;p&gt;After days of hard work we ended up with our lovely crafted code base, a
portable CMake build system and we are now facing the task to generate a proper
Doxygen documentation for our anxious customer. The solution, widely adopted,
seems to be the one and only that can be found while googling and, to me, looks
not so neat. So I tried to come up with a different approach.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>