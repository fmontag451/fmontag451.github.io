<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on /dev/null</title>
    <link>https://nazavode.github.io/categories/development/</link>
    <description>Recent content in Development on /dev/null</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 20 Feb 2014 22:30:51 +0100</lastBuildDate>
    <atom:link href="https://nazavode.github.io/categories/development/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Idiomatic C&#43;&#43;</title>
      <link>https://nazavode.github.io/blog/2014/02/idiomatic-c/</link>
      <pubDate>Thu, 20 Feb 2014 22:30:51 +0100</pubDate>
      
      <guid>https://nazavode.github.io/blog/2014/02/idiomatic-c/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve just &lt;a href=&#34;(http://www.slideshare.net/fficarelli/idiomatic-c)&#34;&gt;uploaded&lt;/a&gt; a minimal collection of most wanted and widely accepted idioms and coding conventions
for C++ development presented along with examples and comments. The lecture targets performance oriented codes so
emphasis is on performance-friendly techniques.&lt;/p&gt;

&lt;p&gt;Topics covered:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Design issues: idioms and best practices&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Resource Aquisition Is Initialization (RAII)&lt;/li&gt;
&lt;li&gt;Ownership semantics and smart pointers&lt;/li&gt;
&lt;li&gt;Header files: dependencies and decoupling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. Objects Construction/Destruction/Copying&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Designing constructors&lt;/li&gt;
&lt;li&gt;Rule Of Three&lt;/li&gt;
&lt;li&gt;Transactional programming&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. Namespaces&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ADL/Koenig Lookup&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4. Static analyzers survey&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You can find full presentation materials &lt;a href=&#34;(http://www.slideshare.net/fficarelli/idiomatic-c)&#34;&gt;on Slideshare&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Documentation with Doxygen and CMake: a (slightly) improved approach</title>
      <link>https://nazavode.github.io/blog/2013/01/documentation-with-doxygen-and-cmake-a-slightly-improved-approach/</link>
      <pubDate>Sat, 19 Jan 2013 22:30:51 +0100</pubDate>
      
      <guid>https://nazavode.github.io/blog/2013/01/documentation-with-doxygen-and-cmake-a-slightly-improved-approach/</guid>
      <description>&lt;p&gt;Well, after days of hard work we ended up with our lovely crafted code base, a portable CMake build system and we are
now facing the task to generate a proper Doxygen documentation for our anxious customer. The solution, widely adopted,
seems to be the one and only that can be found while googling:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;#-- Adds an Option to toggle the generation of the API documentation
option(BUILD_DOCUMENTATION &amp;quot;Use Doxygen to create the HTML based API documentation&amp;quot; OFF)
IF(BUILD_DOCUMENTATION)
  FIND_PACKAGE(Doxygen)
  IF(NOT DOXYGEN_FOUND)
    message(FATAL_ERROR &amp;quot;Doxygen is needed to build the documentation&amp;quot;)
  ENDIF()
  #-- Configure the Template Doxyfile for our specific project
  configure_file(Doxyfile.in ${PROJECT_BINARY_DIR}/Doxyfile @ONLY IMMEDIATE)
  #-- Add a custom target to run Doxygen when ever the project is built
  add_custom_target (Docs ALL
    COMMAND ${DOXYGEN_EXECUTABLE} ${PROJECT_BINARY_DIR}/Doxyfile
    SOURCES ${PROJECT_BINARY_DIR}/Doxyfile)
  # IF you do NOT want the documentation to be generated EVERY time you build the project
  # then leave out the &#39;ALL&#39; keyword from the above command.
ENDIF()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, even if the above solution works like a charm, it exposes a flaw that makes its adoption very annoying:
&lt;strong&gt;Doxygen will be triggered every time we run make, even if nothing has changed&lt;/strong&gt;.
Oh, &lt;em&gt;every time&lt;/em&gt; means exactly &lt;em&gt;every time&lt;/em&gt;: each make invocation (make, make install, etc&amp;hellip;) will flood your shell
with the utterly verbose output from Doxygen even if that step is obviously useless. Yes, we have added that &lt;code&gt;ALL&lt;/code&gt; flag
to &lt;code&gt;ADD_CUSTOM_TARGET&lt;/code&gt; but this is the only way to have our documentation generated along with the default targets
(otherwise our &lt;code&gt;BUILD_DOCUMENTATION&lt;/code&gt; flag would be ignored except for an explicit &lt;code&gt;make doc&lt;/code&gt;). This behavior is correct
and the point is well highlighted in the CMake reference for
&lt;a href=&#34;https://cmake.org/cmake/help/v2.8.10/cmake.html#command:add_custom_target&#34;&gt;&lt;code&gt;ADD_CUSTOM_TARGET&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The target has no output file and is ALWAYS CONSIDERED OUT OF DATE even if the commands
try to create a file with the name of the target. Use ADD_CUSTOM_COMMAND to generate a
file with dependencies.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, it seems that we are using the wrong tool. &lt;strong&gt;How can we add a Doxygen target with a real dependency checking?&lt;/strong&gt;
The neat trick lies in the combined use of two different commands:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ADD_CUSTOM_COMMAND&lt;/code&gt; will take care of dependency checking, firing up Doxygen if and only if something (which the
documentation depends on) has really changed since last build;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ADD_CUSTOM_TARGET&lt;/code&gt; will allow us to have a convenient and elegant make doc target, eventually added to default set.
After a bit of trial-and-error, I ended up with a bunch of lines of code that seems to work as we wanted:&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmake&#34;&gt;option(BUILD_DOCUMENTATION
    &amp;quot;Create and install the HTML based API documentation (requires Doxygen)&amp;quot; OFF)
IF(BUILD_DOCUMENTATION)
  FIND_PACKAGE(Doxygen)
  IF(NOT DOXYGEN_FOUND)
    MESSAGE(FATAL_ERROR &amp;quot;Doxygen is needed to build the documentation.&amp;quot;)
  ENDIF()

  SET( doxyfile_in          ${CMAKE_CURRENT_SOURCE_DIR}/Doxyfile.in)
  SET( doxyfile             ${PROJECT_BINARY_DIR}/Doxyfile)
  SET( doxy_html_index_file ${CMAKE_CURRENT_BINARY_DIR}/html/index.html)
  SET( doxy_output_root     ${CMAKE_CURRENT_BINARY_DIR}) # Pasted into Doxyfile.in
  SET( doxy_input           ${PROJECT_SOURCE_DIR}/src) # Pasted into Doxyfile.in
  SET( doxy_extra_files     ${CMAKE_CURRENT_SOURCE_DIR}/mainpage.dox) # Pasted into Doxyfile.in

  CONFIGURE_FILE( ${doxyfile_in} ${doxyfile} @ONLY )

  ADD_CUSTOM_COMMAND(
    OUTPUT ${doxy_html_index_file}
    COMMAND ${DOXYGEN_EXECUTABLE} ${doxyfile}
    # The following should be ${doxyfile} only but it
    # will break the dependency.
    # The optimal solution would be creating a
    # custom_command for ${doxyfile} generation
    # but I still have to figure out how...
    MAIN_DEPENDENCY ${doxyfile} ${doxyfile_in}
    DEPENDS project_targets ${doxy_extra_files}
    COMMENT &amp;quot;Generating HTML documentation&amp;quot;
  )

  ADD_CUSTOM_TARGET( doc ALL DEPENDS ${doxy_html_index_file} )

  INSTALL( DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/html DESTINATION share/doc )
ENDIF()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The point is that we still have our &lt;code&gt;doc&lt;/code&gt; custom target (added to default targets) that is going to be fired every time
but the actual build step is protected by the custom command that will check for the right dependencies. Just a couple
of remarks:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;DEPENDS&lt;/code&gt; option on the custom command must list all of the targets, files and whatever your documentation depends on;&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;${doxyfile_in}&lt;/code&gt; dependency is an overshoot but, as I say in the comment, removing it will break the dependency checking. The ideal solution would be specifying &lt;code&gt;${doxyfile}&lt;/code&gt; only, letting it to trigger a lower-level custom command intended to configure and generate &lt;code&gt;${doxyfile_in}&lt;/code&gt;. I&amp;rsquo;m still trying to find an elegant solution to this little aesthetic flaw.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Resources:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cmake.org/cmake/help/v2.8.10/cmake.html&#34;&gt;CMake Reference Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.bluequartz.net/projects/EIM_Segmentation/SoftwareDocumentation/html/usewithcmakeproject.html&#34;&gt;Use Doxygen with a CMake Based Project&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>