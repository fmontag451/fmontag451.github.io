<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Talk on /dev/null</title>
    <link>https://nazavode.github.io/categories/talk/</link>
    <description>Recent content in Talk on /dev/null</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 21 Jul 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://nazavode.github.io/categories/talk/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Look ma, no CUDA! Programming GPUs with modern C&#43;&#43; and SYCL</title>
      <link>https://nazavode.github.io/blog/sycl/</link>
      <pubDate>Sun, 21 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://nazavode.github.io/blog/sycl/</guid>
      <description>Back in 2009 when I began doing real work with GPGPUs and CUDA in the context of large scale HPC simulations, the developer experience was dreadful. Sure, for the right algorithm and after lots of blood and tears, performances usually turned out excellent. But before production, comes the poor developer. Debugging CUDA kernels was a nightmare: whenever I had to track down a bug I had to fire up a dedicated gaming rig (bought just for that purpose) because debuggers needed two identical GPUs to work (when they actually worked, and that happened only if you spelled your prayers right the night before).</description>
    </item>
    
    <item>
      <title>Understanding performance with Google Benchmark @ Italian C&#43;&#43; Meetup</title>
      <link>https://nazavode.github.io/blog/google-benchmark/</link>
      <pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://nazavode.github.io/blog/google-benchmark/</guid>
      <description>During the last meetup of the Italian C++ Community in Modena, Italy I had the chance to give a talk about profiling C++ code. The whole game boils down to understanding what&amp;rsquo;s going on when you have to cope with very smart optimizing compilers, NUMA architectures and speculative, superscalar CPUs: in this quest for knowledge we are lucky enough to have some extremely useful tools like the holy perf and micro benchmarks, using the excellent Google Benchmark for instance.</description>
    </item>
    
  </channel>
</rss>