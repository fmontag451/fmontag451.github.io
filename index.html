<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>/dev/null &middot; Federico Ficarelli</title>

  
  <link rel="stylesheet" href="https://nazavode.github.io/css/poole.css">
  <link rel="stylesheet" href="https://nazavode.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://nazavode.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="https://nazavode.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="https://nazavode.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="https://nazavode.github.io/css/highlight/default.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

  
  
  
  <link href="https://nazavode.github.io/index.xml" rel="alternate" type="application/rss+xml" title="/dev/null &middot; Federico Ficarelli" />

  <meta name="description" content="Just volatile hacks.">
  <meta name="keywords" content="hacking,development,software,python,c&#43;&#43;,c99,algorithms">
  

  
  <script src="//ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js"></script>
  <script>
    WebFont.load({
      google: {
        families: ['Raleway']
      }
    });
  </script>

</head>
<body class="theme-base-sulphur-00">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
      <h1>/dev/null</h1>
      <p class="lead">volatile hacks by Federico Ficarelli</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="https://nazavode.github.io/">posts</a></li>
      
      <li class="sidebar-nav-item"><a href="https://nazavode.github.io/about/">About</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      <a href="https://github.com/nazavode"><i class="fa fa-github-square fa-2x"></i></a>
      
      
      <a href="https://it.linkedin.com/in/fficarelli"><i class="fa fa-linkedin-square fa-2x"></i></a>
      <a href="https://plus.google.com/&#43;FedericoFicarelli"><i class="fa fa-google-plus-square fa-2x"></i></a>
      
      <a href="https://twitter.com/fficarelli"><i class="fa fa-twitter-square fa-2x"></i></a>
      
      
      </li>
    </ul>

    

    <p class="footnote">&copy; 2015 Federico Ficarelli<br/>
       Powered by <a href="http://gohugo.io">Hugo</a></p>
  </div>
</div>


<div class="content container">
  <div class="posts">
    
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://nazavode.github.io/blog/2015/12/move-on/">Move on</a>
      </h1>
      <span class="post-date">Dec 17, 2015 &middot; 
      </span>
      
      <p>Just moved my <a href="https://devnone.wordpress.com">old blog</a> to the combo
that mixes <a href="https://pages.github.com/">GitHub Pages</a> and the amazing <a href="https://gohugo.io/">Hugo</a>
static site generator.</p>

<p>The porting process is actually painless: checkout one of the beautifully crafted themes
(I opted for <a href="https://github.com/zyro/hyde-x">hyde-x</a> that looks clean enough),
tweak it a bit to fit your needs, convert your Wordpress posts through an
<a href="https://domchristie.github.io/to-markdown/">html to Markdown converter</a> and push everything to the proper
<a href="https://github.com/nazavode/nazavode.github.io">GitHub repo</a>.</p>

<p>The result is pretty promising.</p>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://nazavode.github.io/blog/2014/02/idiomatic-c/">Idiomatic C&#43;&#43;</a>
      </h1>
      <span class="post-date">Feb 20, 2014 &middot; 
      
      <br/>
      <a class="label" href="https://nazavode.github.io/categories/development">Development</a>
      </span>
      
      <p>I&rsquo;ve just <a href="(http://www.slideshare.net/fficarelli/idiomatic-c)">uploaded</a> a minimal collection of most wanted and widely accepted idioms and coding conventions
for C++ development presented along with examples and comments. The lecture targets performance oriented codes so
emphasis is on performance-friendly techniques.</p>

<p>Topics covered:</p>

<p><strong>1. Design issues: idioms and best practices</strong></p>

<ul>
<li>Resource Aquisition Is Initialization (RAII)</li>
<li>Ownership semantics and smart pointers</li>
<li>Header files: dependencies and decoupling</li>
</ul>

<p><strong>2. Objects Construction/Destruction/Copying</strong></p>

<ul>
<li>Designing constructors</li>
<li>Rule Of Three</li>
<li>Transactional programming</li>
</ul>

<p><strong>3. Namespaces</strong></p>

<ul>
<li>ADL/Koenig Lookup</li>
</ul>

<p><strong>4. Static analyzers survey</strong></p>

<p>You can find full presentation materials <a href="(http://www.slideshare.net/fficarelli/idiomatic-c)">on Slideshare</a>.</p>

      
    </div>
    
    <div class="post">
      <h1 class="post-title">
        <a href="https://nazavode.github.io/blog/2013/01/documentation-with-doxygen-and-cmake-a-slightly-improved-approach/">Documentation with Doxygen and CMake: a (slightly) improved approach</a>
      </h1>
      <span class="post-date">Jan 19, 2013 &middot; 
      
      <br/>
      <a class="label" href="https://nazavode.github.io/categories/development">Development</a>
      </span>
      
      <p>Well, after days of hard work we ended up with our lovely crafted code base, a portable CMake build system and we are
now facing the task to generate a proper Doxygen documentation for our anxious customer. The solution, widely adopted,
seems to be the one and only that can be found while googling:</p>

<pre><code class="language-cmake">#-- Adds an Option to toggle the generation of the API documentation
option(BUILD_DOCUMENTATION &quot;Use Doxygen to create the HTML based API documentation&quot; OFF)
IF(BUILD_DOCUMENTATION)
  FIND_PACKAGE(Doxygen)
  IF(NOT DOXYGEN_FOUND)
    message(FATAL_ERROR &quot;Doxygen is needed to build the documentation&quot;)
  ENDIF()
  #-- Configure the Template Doxyfile for our specific project
  configure_file(Doxyfile.in ${PROJECT_BINARY_DIR}/Doxyfile @ONLY IMMEDIATE)
  #-- Add a custom target to run Doxygen when ever the project is built
  add_custom_target (Docs ALL
    COMMAND ${DOXYGEN_EXECUTABLE} ${PROJECT_BINARY_DIR}/Doxyfile
    SOURCES ${PROJECT_BINARY_DIR}/Doxyfile)
  # IF you do NOT want the documentation to be generated EVERY time you build the project
  # then leave out the 'ALL' keyword from the above command.
ENDIF()
</code></pre>

<p>Well, even if the above solution works like a charm, it exposes a flaw that makes its adoption very annoying:
<strong>Doxygen will be triggered every time we run make, even if nothing has changed</strong>.
Oh, <em>every time</em> means exactly <em>every time</em>: each make invocation (make, make install, etc&hellip;) will flood your shell
with the utterly verbose output from Doxygen even if that step is obviously useless. Yes, we have added that <code>ALL</code> flag
to <code>ADD_CUSTOM_TARGET</code> but this is the only way to have our documentation generated along with the default targets
(otherwise our <code>BUILD_DOCUMENTATION</code> flag would be ignored except for an explicit <code>make doc</code>). This behavior is correct
and the point is well highlighted in the CMake reference for
<a href="https://cmake.org/cmake/help/v2.8.10/cmake.html#command:add_custom_target"><code>ADD_CUSTOM_TARGET</code></a>:</p>

<blockquote>
<p>The target has no output file and is ALWAYS CONSIDERED OUT OF DATE even if the commands
try to create a file with the name of the target. Use ADD_CUSTOM_COMMAND to generate a
file with dependencies.</p>
</blockquote>

<p>So, it seems that we are using the wrong tool. <strong>How can we add a Doxygen target with a real dependency checking?</strong>
The neat trick lies in the combined use of two different commands:</p>

<ol>
<li><code>ADD_CUSTOM_COMMAND</code> will take care of dependency checking, firing up Doxygen if and only if something (which the
documentation depends on) has really changed since last build;</li>
<li><code>ADD_CUSTOM_TARGET</code> will allow us to have a convenient and elegant make doc target, eventually added to default set.
After a bit of trial-and-error, I ended up with a bunch of lines of code that seems to work as we wanted:</li>
</ol>

<pre><code class="language-cmake">option(BUILD_DOCUMENTATION
    &quot;Create and install the HTML based API documentation (requires Doxygen)&quot; OFF)
IF(BUILD_DOCUMENTATION)
  FIND_PACKAGE(Doxygen)
  IF(NOT DOXYGEN_FOUND)
    MESSAGE(FATAL_ERROR &quot;Doxygen is needed to build the documentation.&quot;)
  ENDIF()

  SET( doxyfile_in          ${CMAKE_CURRENT_SOURCE_DIR}/Doxyfile.in)
  SET( doxyfile             ${PROJECT_BINARY_DIR}/Doxyfile)
  SET( doxy_html_index_file ${CMAKE_CURRENT_BINARY_DIR}/html/index.html)
  SET( doxy_output_root     ${CMAKE_CURRENT_BINARY_DIR}) # Pasted into Doxyfile.in
  SET( doxy_input           ${PROJECT_SOURCE_DIR}/src) # Pasted into Doxyfile.in
  SET( doxy_extra_files     ${CMAKE_CURRENT_SOURCE_DIR}/mainpage.dox) # Pasted into Doxyfile.in

  CONFIGURE_FILE( ${doxyfile_in} ${doxyfile} @ONLY )

  ADD_CUSTOM_COMMAND(
    OUTPUT ${doxy_html_index_file}
    COMMAND ${DOXYGEN_EXECUTABLE} ${doxyfile}
    # The following should be ${doxyfile} only but it
    # will break the dependency.
    # The optimal solution would be creating a
    # custom_command for ${doxyfile} generation
    # but I still have to figure out how...
    MAIN_DEPENDENCY ${doxyfile} ${doxyfile_in}
    DEPENDS project_targets ${doxy_extra_files}
    COMMENT &quot;Generating HTML documentation&quot;
  )

  ADD_CUSTOM_TARGET( doc ALL DEPENDS ${doxy_html_index_file} )

  INSTALL( DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/html DESTINATION share/doc )
ENDIF()
</code></pre>

<p>The point is that we still have our <code>doc</code> custom target (added to default targets) that is going to be fired every time
but the actual build step is protected by the custom command that will check for the right dependencies. Just a couple
of remarks:</p>

<ul>
<li>the <code>DEPENDS</code> option on the custom command must list all of the targets, files and whatever your documentation depends on;</li>
<li>the <code>${doxyfile_in}</code> dependency is an overshoot but, as I say in the comment, removing it will break the dependency checking. The ideal solution would be specifying <code>${doxyfile}</code> only, letting it to trigger a lower-level custom command intended to configure and generate <code>${doxyfile_in}</code>. I&rsquo;m still trying to find an elegant solution to this little aesthetic flaw.</li>
</ul>

<hr />

<p>Resources:</p>

<ul>
<li><a href="http://www.cmake.org/cmake/help/v2.8.10/cmake.html">CMake Reference Manual</a></li>
<li><a href="http://www.bluequartz.net/projects/EIM_Segmentation/SoftwareDocumentation/html/usewithcmakeproject.html">Use Doxygen with a CMake Based Project</a></li>
</ul>

      
    </div>
    
    
    
  </div>
</div>


<script src="https://nazavode.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>

